前面分析客户端代理调用的时候，从[ServiceCommandProvider](/surging/客户端代理调用?id=servicecommandprovider)取服务命令的时候，跳过了Zookeeper或Consul相关的逻辑。直接从本地扫描接口得到的结果中取出。
```csharp
public async Task<ServiceCommand> GetCommandAsync(string serviceId)
{
    var result = new ServiceCommand();
    var manager = _serviceProvider.GetService<IServiceCommandManager>();
    if (manager == null)
    {
        var command = (from q in _serviceEntryManager.GetEntries()
                        let k = q.Attributes
                        where k.OfType<CommandAttribute>().Count() > 0 && q.Descriptor.Id == serviceId
                        select k.OfType<CommandAttribute>().FirstOrDefault()).FirstOrDefault();
        result = ConvertServiceCommand(command);
    }
    else
    {
        var commands = await manager.GetServiceCommandsAsync();
        result = ConvertServiceCommand(commands.Where(p => p.ServiceId == serviceId).FirstOrDefault());
    }
    _serviceCommand.AddOrUpdate(serviceId, result, (s, r) => result);
    return result;
}
```
`IServiceCommandManager`的实现有`ConsulServiceCommandManager`与`ZookeeperServiceCommandManager`。

本节以ConsulServiceCommandManager为例进行分析。

### ConsulServiceCommandManager

服务命令的注册：
```csharp
public static IServiceHostBuilder UseServer(this IServiceHostBuilder hostBuilder, string ip, int port, string token="True")
{
    return hostBuilder.MapServices(mapper =>
    {
        mapper.Resolve<IServiceCommandManager>().SetServiceCommandsAsync();
        ...
        ...
        ...
    });
}
```
`SetServiceCommandsAsync`:

```csharp
// ServiceCommandManagerBase.cs
public virtual async Task SetServiceCommandsAsync()
{
    List<ServiceCommandDescriptor> serviceCommands = new List<ServiceCommandDescriptor>();
    await Task.Run(() =>
    {
        var commands = (from q in _serviceEntryManager.GetEntries()
                        let k = q.Attributes
                        select new { ServiceId = q.Descriptor.Id, Command = k.OfType<CommandAttribute>().FirstOrDefault() }).ToList();
        commands.ForEach(command => serviceCommands.Add(ConvertServiceCommand(command.ServiceId, command.Command)));
        InitServiceCommandsAsync(serviceCommands);
    });
}
```

从`DefaultServiceEntryManager`取出`ServiceEntry`列表。
```csharp
// DefaultServiceEntryManager.cs
public DefaultServiceEntryManager(IEnumerable<IServiceEntryProvider> providers)
{
    var list = new List<ServiceEntry>();
    foreach (var provider in providers)
    {
        var entries = provider.GetEntries().ToArray();
        foreach (var entry in entries)
        {
            if (list.Any(i => i.Descriptor.Id == entry.Descriptor.Id))
                throw new InvalidOperationException($"本地包含多个Id为：{entry.Descriptor.Id} 的服务条目。");
        }
        list.AddRange(entries);
    }
    _serviceEntries = list.ToArray();
}
```
```csharp
//AttributeServiceEntryProvider.cs
public IEnumerable<ServiceEntry> GetEntries()
{
    var services = _types.Where(i =>
    {
        var typeInfo = i.GetTypeInfo();
        return typeInfo.IsInterface && typeInfo.GetCustomAttribute<ServiceBundleAttribute>() != null && _serviceProvider.Current.IsRegistered(i);
    }).Distinct().ToArray();

    if (_logger.IsEnabled(LogLevel.Information))
    {
        _logger.LogInformation($"发现了以下服务：{string.Join(",", services.Select(i => i.ToString()))}。");
    }
    var entries = new List<ServiceEntry>();
    foreach (var service in services)
    {
        entries.AddRange( _clrServiceEntryFactory.CreateServiceEntry(service));
    }
    return entries;
}
```

```csharp
private static IServiceBuilder AddRuntime(this IServiceBuilder builder)
{
    var services = builder.Services;

    services.RegisterType(typeof(ClrServiceEntryFactory)).As(typeof(IClrServiceEntryFactory)).SingleInstance();

    services.Register(provider =>
    {
        try
        {
            var assemblys = GetReferenceAssembly();
            var types = assemblys.SelectMany(i => i.ExportedTypes).ToArray();
            return new AttributeServiceEntryProvider(types, provider.Resolve<IClrServiceEntryFactory>(),
                    provider.Resolve<ILogger<AttributeServiceEntryProvider>>(), provider.Resolve<CPlatformContainer>());
        }
        finally
        {
            _referenceAssembly.Clear();
        }
    }).As<IServiceEntryProvider>();
    builder.Services.RegisterType(typeof(DefaultServiceEntryManager)).As(typeof(IServiceEntryManager)).SingleInstance();
    return builder;
}
```

过程与客户端代理调用一样，都是调用`AddRuntime`扩展方法：
* 将`DefaultServiceEntryManager`实例注入`ConsulServiceCommandManager`。
* `DefaultServiceEntryManager`实例化需要注入`IServiceEntryProvider`服务，也就是`AttributeServiceEntryProvider`实例。
* `AttributeServiceEntryProvider`是以委托的方式注册的，实例化的时候会扫描本地程序集，并导出类型传入构造函数。
* 调用`AttributeServiceEntryProvider`实例`GetEntries`方法，会筛选类型列表，得到服务接口列表，然后调用`ClrServiceEntryFactory`实例方法`CreateServiceEntry`创建`ServiceEntry`实例。
* 将从`DefaultServiceEntryManager`实例中取到`ServiceEntry`列表转换为`ServiceCommandDescriptor`列表，即`ServiceCommand`列表（ServiceCommandDescriptor继承ServiceCommand），主要是转换`CommandAttribute`。

!>扫描程序集 > 服务接口列表 > ServiceEntry列表 > ServiceCommandDescriptor列表(ServiceCommand)

!>ServiceEntry列表缓存在`DefaultServiceEntryManager`实例的`_serviceEntries`属性中。

SetServiceCommandsAsync方法最后会调用InitServiceCommandsAsync方法，并将`ServiceCommandDescriptor`列表传入，方法实现在ConsulServiceCommandManager中：
```csharp
//ConsulServiceCommandManager.cs
protected override async Task InitServiceCommandsAsync(IEnumerable<ServiceCommandDescriptor> serviceCommands)
{
    var commands = await GetServiceCommands(serviceCommands.Select(p => $"{ _configInfo.CommandPath}{ p.ServiceId}"));
    if (commands.Count() == 0)
    {
        await SetServiceCommandsAsync(serviceCommands);
    }
}
```
>先从节点去服务命令，取不到再设置。

```csharp
public ConfigInfo(string connectionString,string routePath = "services/serviceRoutes/",
             string subscriberPath = "services/serviceSubscribers/",
            string commandPath = "services/serviceCommands/") :
            this(connectionString, TimeSpan.FromSeconds(20), routePath, subscriberPath,commandPath)
{
}
```

!>`CommandPath`默认为"services/serviceCommands/"


从节点上获取服务命令：
```csharp
private async Task<ServiceCommandDescriptor[]> GetServiceCommands(IEnumerable<string> childrens)
{
    var rootPath = _configInfo.CommandPath;
    if (!rootPath.EndsWith("/"))
        rootPath += "/";

    childrens = childrens.ToArray();
    var serviceCommands = new List<ServiceCommandDescriptor>(childrens.Count());

    foreach (var children in childrens)
    {
        if (_logger.IsEnabled(Microsoft.Extensions.Logging.LogLevel.Debug))
            _logger.LogDebug($"准备从节点：{children}中获取服务命令信息。");

        var serviceCommand = await GetServiceCommand(children);
        if (serviceCommand != null)
            serviceCommands.Add(serviceCommand);
    }
    return serviceCommands.ToArray();
}
```

获取服务命令：
```csharp
private async Task<ServiceCommandDescriptor> GetServiceCommand(string path)
{
    ServiceCommandDescriptor result = null;
    var watcher = new NodeMonitorWatcher(_consul, _manager, path,
            (oldData, newData) => NodeChange(oldData, newData));
    var queryResult = await _consul.KV.Keys(path);
    if (queryResult.Response != null)
    {
        var data = (await _consul.GetDataAsync(path));
        if (data != null)
        {
            watcher.SetCurrentData(data);
            result = GetServiceCommand(data);
        }
    }
    return result;
}
```
>path例子："services/serviceCommands/Surging.IModuleServices.Common.IUserService.Authentication_requestData"

根据path从consul`KV`获取服务命令信息。如果取到则反序列化为`ServiceCommandDescriptor`。

### NodeMonitorWatcher
